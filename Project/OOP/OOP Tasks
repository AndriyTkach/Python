2. Напишите программу по следующему описанию. Есть класс "Воин". От него создаются два
экземпляра-юнита. 
Каждому устанавливается здоровье в 100 очков. В случайном порядке они
бьют друг друга. Тот, кто бьет, здоровья не теряет. У того, кого бьют, оно уменьшается на 20
очков от одного удара. После каждого удара надо выводить сообщение, какой юнит атаковал, и
сколько у противника осталось здоровья. Как только у кого-то заканчивается ресурс здоровья,
программа завершается сообщением о том, кто одержал победу
#----------------------------------------------------------------------------------------------------------
3.Напишите программу по следующему описанию:
    1. Есть класс Person, конструктор которого принимает три параметра (не учитывая self) –
    имя, фамилию и квалификацию специалиста. Квалификация имеет значение заданное по
    умолчанию, равное единице.
    2. У класса Person есть метод, который возвращает строку, включающую в себя всю
    информацию о сотруднике.
    3. Класс Person содержит деструктор, который выводит на экран фразу "До свидания,
    мистер …" (вместо троеточия должны выводиться имя и фамилия объекта).
    4. В основной ветке программы создайте три объекта класса Person. Посмотрите
    информацию о сотрудниках и увольте самое слабое звено.
    5. В конце программы добавьте функцию input(), чтобы скрипт не завершился сам, пока не
    будет нажат Enter. Иначе вы сразу увидите как удаляются все объекты при завершении
    работы программы.
#----------------------------------------------------------------------------------------------------------
4. Разработайте программу по следующему описанию.
В некой игре-стратегии есть солдаты и герои. 
У всех есть свойство, содержащее уникальный
номер объекта, и свойство, в котором хранится принадлежность команде. У солдат есть метод
"иду за героем", который в качестве аргумента принимает объект типа "герой". У героев есть
метод увеличения собственного уровня.
В основной ветке программы создается по одному герою для каждой команды. В цикле
генерируются объекты-солдаты. 
Их принадлежность команде определяется случайно. Солдаты
разных команд добавляются в разные списки.
Измеряется длина списков солдат противоборствующих команд и выводится на экран. У героя,
принадлежащего команде с более длинным списком, увеличивается уровень.
Отправьте одного из солдат первого героя следовать за ним. Выведите на экран
идентификационные номера этих двух юнитов.
#----------------------------------------------------------------------------------------------------------
5. В качестве практической работы попробуйте самостоятельно перегрузить оператор сложения.
Для его перегрузки используется метод __add__(). Он вызывается, когда объекты класса,
имеющего данный метод, фигурируют в операции сложения, причем с левой стороны. Это
значит, что в выражении a + b у объекта a должен быть метод __add__(). Объект b может
быть чем угодно, но чаще всего он бывает объектом того же класса. Объект b будет
автоматически передаваться в метод __add__() в качестве второго аргумента (первый – self).
Отметим, в Python также есть правосторонний метод перегрузки сложения – __radd__().
Согласно полиморфизму ООП, возвращать метод __add__() может что угодно. Может вообще
ничего не возвращать, а "молча" вносить изменения в какие-то уже существующие объекты.
Допустим, в вашей программе метод перегрузки сложения будет возвращать новый объект того же класса.
#----------------------------------------------------------------------------------------------------------
6. Разработайте класс с "полной инкапсуляцией", доступ к атрибутам которого и изменение
данных реализуются через вызовы методов. В объектно-ориентированном программировании
принято имена методов для извлечения данных начинать со слова get (взять), а имена методов, в
которых свойствам присваиваются значения, – со слова set (установить). Например, getField, setField.
#----------------------------------------------------------------------------------------------------------
7. Приведенная выше программа имеет ряд недочетов и недоработок. Требуется исправить и
доработать, согласно следующему плану.
При вычислении оклеиваемой поверхности мы не "портим" поле self.square. В нем так и
остается полная площадь стен. Ведь она может понадобиться, если состав списка wd изменится,
и придется заново вычислять оклеиваемую площадь.
Однако в классе не предусмотрено сохранение длин сторон, хотя они тоже могут понадобиться.
Например, если потребуется изменить одну из величин у уже существующего объекта. Площадь
же помещения всегда можно вычислить, если хранить исходные параметры. Поэтому сохранять
саму площадь в поле не обязательно.
Исправьте код так, чтобы у объектов Room были только четыре поля – width, lenght, height и wd.
Площади (полная и оклеиваемая) должны вычислять лишь при необходимости путем вызова
методов. Программа вычисляет площадь под оклейку, но ничего не говорит о том, сколько потребуется
рулонов обоев. Добавьте метод, который принимает в качестве аргументов длину и ширину
одного рулона, а возвращает количество необходимых, исходя из оклеиваемой площади.
Разработайте интерфейс программы. Пусть она запрашивает у пользователя данные и выдает
ему площадь оклеиваемой поверхности и количество необходимых рулонов.
#----------------------------------------------------------------------------------------------------------
8. Напишите класс Snow по следующему описанию.
В конструкторе класса инициируется поле, содержащее количество снежинок, выраженное
целым числом.
Класс включает методы перегрузки арифметических операторов: __add__() – сложение,
__sub__() – вычитание, __mul__() – умножение, __truediv__() – деление. В классе код этих
методов должен выполнять увеличение или уменьшение количества снежинок на число n или в
n раз. Метод __truediv__() перегружает обычное (/), а не целочисленное (//) деление. Однако
пусть в методе происходит округление значения до целого числа.
Класс включает метод makeSnow(), который принимает сам объект и число снежинок в ряду, а
возвращает строку вида "*****\n. Функция repr() n*****\n. Функция repr() n*****…", где количество снежинок между '\n', 
равно переданному аргументу, а количество рядов вычисляется, исходя из общего количества
снежинок.
Вызов объекта класса Snow в нотации функции с одним аргументом, должен приводить к
перезаписи значения поля, в котором хранится количество снежинок, на переданное в качестве
аргумента значение.
#----------------------------------------------------------------------------------------------------------
9. В практической работе урока 7 "Композиция" требовалось разработать интерфейс
взаимодействия с пользователем. Разнесите сам класс и интерфейс по разным файлам. Какой из
них выполняет роль модуля, а какой – скрипта? Оба файла можно поместить в один каталог
#----------------------------------------------------------------------------------------------------------
10. Выполните полное документирование модуля, созданного в практической работе прошлого
урока.
#----------------------------------------------------------------------------------------------------------
11. Пусть необходимо разработать виртуальную модель процесса обучения. В программе должны
быть объекты-ученики, учитель, кладезь знаний.
Потребуется три класса – "учитель", "ученик", "данные". Учитель и ученик во многом похожи,
оба – люди. Значит, их классы могут принадлежать одному надклассу "человек". Однако в
контексте данной задачи у учителя и ученика вряд ли найдутся общие атрибуты.
Определим, что должны уметь объекты для решения задачи "увеличить знания":
• Ученик должен уметь брать информацию и превращать ее в свои знания.
• Учитель должен уметь учить группу учеников.
• Данные могут представлять собой список знаний. Элементы будут извлекаться по
индексу.
Может ли в этой программе ученик учиться без учителя? Если да, пусть научится чему-нибудь сам.
Добавьте в класс Pupil метод, позволяющий ученику случайно "забывать" какую-нибудь часть
своих знаний.
#----------------------------------------------------------------------------------------------------------
13. Приведенный в конце урока пример плохой. Мы можем менять значения полей dia и h объекта
за пределами класса простым присваиванием (например, a.dia = 10). При этом площадь никак не
будет пересчитываться. Также мы можем назначить новое значение для площади, как простым
присваиванием, так и вызовом функции make_area() с последующим присваиванием. Например,
a.area = a.make_area(2, 3). При этом не меняются высота и диаметр.
Защитите код от возможных логических ошибок следующим образом:
• Свойствам dia и h объекта по-прежнему можно выполнять присваивание за пределами
класса. Однако при этом "за кулисами" происходит пересчет площади, т. е. изменение
значения area.
• Свойству area нельзя присваивать за пределами класса. Можно только получать его
значение.
Подсказка: вспомните про метод __setattr__(), упомянутый в уроке про инкапсуляцию.
#----------------------------------------------------------------------------------------------------------
14. Напишите класс-итератор, 
объекты которого генерируют случайные числа в количестве и в
диапазоне, которые передаются в конструктор
#----------------------------------------------------------------------------------------------------------
15. В задании к прошлому уроку требовалось написать класс-итератор, объекты которого
генерируют случайные числа в количестве и в диапазоне, которые передаются в конструктор.
Напишите выполняющую ту же задачу генераторную функцию. В качестве аргументов она
должна принимать количество элементов и диапазон.
