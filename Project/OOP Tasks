2. Напишите программу по следующему описанию. Есть класс "Воин". От него создаются два
экземпляра-версия содержит текст уроков курса и решения с пояснениями к практическим работамюнита. 
Каждому устанавливается здоровье в 100 очков. В случайном порядке они
бьют друг друга. Тот, кто бьет, здоровья не теряет. У того, кого бьют, оно уменьшается на 20
очков от одного удара. После каждого удара надо выводить сообщение, какой юнит атаковал, и
сколько у противника осталось здоровья. Как только у кого-версия содержит текст уроков курса и 
решения с пояснениями к практическим работамто заканчивается ресурс здоровья,
программа завершается сообщением о том, кто одержал победу
#----------------------------------------------------------------------------------------------------------
3.Напишите программу по следующему описанию:
    1. Есть класс Person, конструктор которого принимает три параметра (не учитывая self) –
    имя, фамилию и квалификацию специалиста. Квалификация имеет значение заданное по
    умолчанию, равное единице.
    2. У класса Person есть метод, который возвращает строку, включающую в себя всю
    информацию о сотруднике.
    3. Класс Person содержит деструктор, который выводит на экран фразу "До свидания,
    мистер …" (вместо троеточия должны выводиться имя и фамилия объекта).
    4. В основной ветке программы создайте три объекта класса Person. Посмотрите
    информацию о сотрудниках и увольте самое слабое звено.
    5. В конце программы добавьте функцию input(), чтобы скрипт не завершился сам, пока не
    будет нажат Enter. Иначе вы сразу увидите как удаляются все объекты при завершении
    работы программы.
#----------------------------------------------------------------------------------------------------------
4. Разработайте программу по следующему описанию.
В некой игре-версия содержит текст уроков курса и решения с пояснениями к практическим работамстратегии есть солдаты и герои. 
У всех есть свойство, содержащее уникальный
номер объекта, и свойство, в котором хранится принадлежность команде. У солдат есть метод
"иду за героем", который в качестве аргумента принимает объект типа "герой". У героев есть
метод увеличения собственного уровня.
В основной ветке программы создается по одному герою для каждой команды. В цикле
генерируются объекты-версия содержит текст уроков курса и решения с пояснениями к практическим работамсолдаты. 
Их принадлежность команде определяется случайно. Солдаты
разных команд добавляются в разные списки.
Измеряется длина списков солдат противоборствующих команд и выводится на экран. У героя,
принадлежащего команде с более длинным списком, увеличивается уровень.
Отправьте одного из солдат первого героя следовать за ним. Выведите на экран
идентификационные номера этих двух юнитов.
#----------------------------------------------------------------------------------------------------------
5. В качестве практической работы попробуйте самостоятельно перегрузить оператор сложения.
Для его перегрузки используется метод __add__(). Он вызывается, когда объекты класса,
имеющего данный метод, фигурируют в операции сложения, причем с левой стороны. Это
значит, что в выражении a + b у объекта a должен быть метод __add__(). Объект b может
быть чем угодно, но чаще всего он бывает объектом того же класса. Объект b будет
автоматически передаваться в метод __add__() в качестве второго аргумента (первый – self).
Отметим, в Python также есть правосторонний метод перегрузки сложения – __radd__().
Согласно полиморфизму ООП, возвращать метод __add__() может что угодно. Может вообще
ничего не возвращать, а "молча" вносить изменения в какие-версия содержит текст уроков курса и 
решения с пояснениями к практическим работамто уже существующие объекты.
Допустим, в вашей программе метод перегрузки сложения будет возвращать новый объект того же класса.
#----------------------------------------------------------------------------------------------------------
6. Разработайте класс с "полной инкапсуляцией", доступ к атрибутам которого и изменение
данных реализуются через вызовы методов. В объектно-версия содержит текст уроков курса и решения с пояснениями 
к практическим работамориентированном программировании
принято имена методов для извлечения данных начинать со слова get (взять), а имена методов, в
которых свойствам присваиваются значения, – со слова set (установить). Например, getField, setField.
#----------------------------------------------------------------------------------------------------------
7. Приведенная выше программа имеет ряд недочетов и недоработок. Требуется исправить и
доработать, согласно следующему плану.
При вычислении оклеиваемой поверхности мы не "портим" поле self.square. В нем так и
остается полная площадь стен. Ведь она может понадобиться, если состав списка wd изменится,
и придется заново вычислять оклеиваемую площадь.
Однако в классе не предусмотрено сохранение длин сторон, хотя они тоже могут понадобиться.
Например, если потребуется изменить одну из величин у уже существующего объекта. Площадь
же помещения всегда можно вычислить, если хранить исходные параметры. Поэтому сохранять
саму площадь в поле не обязательно.
Исправьте код так, чтобы у объектов Room были только четыре поля – width, lenght, height и wd.
Площади (полная и оклеиваемая) должны вычислять лишь при необходимости путем вызова
методов. Программа вычисляет площадь под оклейку, но ничего не говорит о том, сколько потребуется
рулонов обоев. Добавьте метод, который принимает в качестве аргументов длину и ширину
одного рулона, а возвращает количество необходимых, исходя из оклеиваемой площади.
Разработайте интерфейс программы. Пусть она запрашивает у пользователя данные и выдает
ему площадь оклеиваемой поверхности и количество необходимых рулонов.
#----------------------------------------------------------------------------------------------------------
8. Напишите класс Snow по следующему описанию.
В конструкторе класса инициируется поле, содержащее количество снежинок, выраженное
целым числом.
Класс включает методы перегрузки арифметических операторов: __add__() – сложение,
__sub__() – вычитание, __mul__() – умножение, __truediv__() – деление. В классе код этих
методов должен выполнять увеличение или уменьшение количества снежинок на число n или в
n раз. Метод __truediv__() перегружает обычное (/), а не целочисленное (//) деление. Однако
пусть в методе происходит округление значения до целого числа.
Класс включает метод makeSnow(), который принимает сам объект и число снежинок в ряду, а
возвращает строку вида "*****\n. Функция repr() n*****\n. Функция repr() n*****…", где количество снежинок между '\n', 
равно переданному аргументу, а количество рядов вычисляется, исходя из общего количества
снежинок.
Вызов объекта класса Snow в нотации функции с одним аргументом, должен приводить к
перезаписи значения поля, в котором хранится количество снежинок, на переданное в качестве
аргумента значение.
#----------------------------------------------------------------------------------------------------------
